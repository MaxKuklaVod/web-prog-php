Отлично! Давайте подробно разберем каждый вопрос.

---

### 1. Понятие и устройство веб-сервера. Протокол HTTP. Структура запросов и ответов.

**Веб-сервер:**

*   **Понятие:** Веб-сервер — это программное обеспечение (а иногда и аппаратный комплекс, на котором это ПО запущено), предназначенное для приема HTTP-запросов от клиентов (обычно веб-браузеров) и возвращения им HTTP-ответов, как правило, вместе с HTML-страницами, изображениями, файлами, медиапотоками или другими данными.
*   **Основные функции:**
    1.  **Прием запросов:** Прослушивание сетевых портов (стандартно 80 для HTTP, 443 для HTTPS) и прием входящих TCP/IP соединений.
    2.  **Обработка запросов:** Анализ HTTP-запроса, определение запрашиваемого ресурса (URL).
    3.  **Поиск/генерация контента:**
        *   Для статических ресурсов (HTML-файлы, картинки, CSS, JS): чтение файла с диска.
        *   Для динамических ресурсов: передача запроса на обработку скрипту (например, PHP, Python, Node.js) через CGI, FastCGI, или модули (mod_php для Apache). Скрипт генерирует HTML или другие данные.
    4.  **Отправка ответа:** Формирование HTTP-ответа, включающего статус-код, заголовки и тело ответа (запрошенный ресурс или результат работы скрипта).
    5.  **Управление соединениями:** Открытие, поддержание и закрытие TCP-соединений.
    6.  **Логирование:** Запись информации о запросах и ошибках в лог-файлы.
    7.  **Аутентификация и авторизация:** Проверка прав доступа к ресурсам.
    8.  **Поддержка HTTPS:** Шифрование данных с помощью SSL/TLS сертификатов.
*   **Популярные веб-серверы:** Apache HTTP Server, Nginx, Microsoft IIS, LiteSpeed.

**Протокол HTTP (HyperText Transfer Protocol):**

*   **Понятие:** Это протокол прикладного уровня, используемый для передачи гипертекстовых документов (например, HTML). Он является основой обмена данными во Всемирной паутине. HTTP — это протокол типа "клиент-сервер", где клиент (браузер) отправляет запрос, а сервер отвечает.
*   **Ключевые характеристики:**
    *   **Текстовый:** Сообщения HTTP (запросы и ответы) в основном текстовые, что делает их читаемыми для человека.
    *   **Без состояния (Stateless):** Каждый запрос обрабатывается сервером независимо, без сохранения информации о предыдущих запросах от того же клиента. Для поддержания состояния используются механизмы вроде Cookies и сессий.
    *   **Расширяемый:** Позволяет добавлять новые заголовки и методы.
*   **Версии:**
    *   **HTTP/1.0:** Базовая версия, одно соединение на один запрос-ответ.
    *   **HTTP/1.1:** Введены постоянные соединения (keep-alive), конвейеризация запросов, улучшено кэширование. Наиболее распространенная версия.
    *   **HTTP/2:** Основан на SPDY от Google. Бинарный протокол, мультиплексирование (несколько запросов/ответов одновременно в одном TCP-соединении), сжатие заголовков, Server Push. Значительно повышает производительность.
    *   **HTTP/3:** Использует протокол QUIC вместо TCP, что решает проблему "head-of-line blocking" на уровне TCP и улучшает производительность в сетях с потерями.

**Структура HTTP-запроса:**

1.  **Стартовая строка (Request Line):**
    *   **Метод (Method):** Тип запроса (GET, POST, PUT, DELETE, HEAD, OPTIONS, etc.).
    *   **URI (Uniform Resource Identifier):** Путь к запрашиваемому ресурсу (например, `/index.php?page=home`).
    *   **Версия HTTP (HTTP Version):** Например, `HTTP/1.1`.
    *   Пример: `GET /path/to/resource?param1=value1 HTTP/1.1`

2.  **Заголовки (Headers):**
    *   Пары "имя: значение", предоставляющие дополнительную информацию о запросе или клиенте.
    *   Примеры:
        *   `Host: www.example.com` (обязателен в HTTP/1.1)
        *   `User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...`
        *   `Accept: text/html,application/xhtml+xml,...`
        *   `Content-Type: application/x-www-form-urlencoded` (для POST-запросов с данными формы)
        *   `Content-Length: 348` (размер тела запроса в байтах)
        *   `Cookie: name=value; name2=value2`

3.  **Пустая строка (CRLF):**
    *   Разделяет заголовки от тела запроса.

4.  **Тело запроса (Message Body - опционально):**
    *   Содержит данные, передаваемые серверу, например, данные HTML-формы (для POST, PUT запросов).
    *   Пример: `username=john&password=secret`

**Структура HTTP-ответа:**

1.  **Стартовая строка (Status Line):**
    *   **Версия HTTP (HTTP Version):** Например, `HTTP/1.1`.
    *   **Код состояния (Status Code):** Трехзначное число, указывающее результат обработки запроса (e.g., 200, 404, 500).
    *   **Поясняющая фраза (Reason Phrase):** Текстовое описание кода состояния (e.g., OK, Not Found, Internal Server Error).
    *   Пример: `HTTP/1.1 200 OK`

2.  **Заголовки (Headers):**
    *   Пары "имя: значение", предоставляющие информацию об ответе или сервере.
    *   Примеры:
        *   `Content-Type: text/html; charset=UTF-8`
        *   `Content-Length: 1256`
        *   `Server: Apache/2.4.41 (Ubuntu)`
        *   `Set-Cookie: sessionId=abcdef12345; HttpOnly`
        *   `Cache-Control: no-cache`
        *   `Location: /new-page.html` (для редиректов, код 301 или 302)

3.  **Пустая строка (CRLF):**
    *   Разделяет заголовки от тела ответа.

4.  **Тело ответа (Message Body - опционально):**
    *   Содержит запрошенный ресурс (HTML-страница, изображение, JSON-данные и т.д.) или сообщение об ошибке.
    *   Пример: `<html><body><h1>Hello World!</h1></body></html>`

---

### 2. Способы передачи информации. Выполнение CGI-скриптов.

**Способы передачи информации (от клиента к серверу):**

В контексте веб-программирования, это в основном относится к тому, как данные от HTML-форм или AJAX-запросов передаются на сервер. Основные методы HTTP, используемые для этого:

1.  **GET:**
    *   Данные передаются как часть URL, в так называемой "строке запроса" (query string), после знака `?`. Пары "имя=значение" разделяются амперсандом `&`.
    *   Пример: `http://example.com/search.php?query=php&category=web`
    *   **Особенности:**
        *   Данные видны в URL (и в истории браузера, логах сервера).
        *   Ограничение на длину URL (обычно около 2000 символов, зависит от браузера и сервера).
        *   Используется для запроса данных, не изменяющих состояние сервера (идемпотентные запросы).
        *   Запросы с GET могут кэшироваться.
        *   Можно добавить в закладки.
    *   В PHP данные доступны через суперглобальный массив `$_GET`.

2.  **POST:**
    *   Данные передаются в теле HTTP-запроса, после заголовков.
    *   **Особенности:**
        *   Данные не видны в URL.
        *   Нет практического ограничения на объем передаваемых данных (ограничения накладываются конфигурацией сервера).
        *   Используется для отправки данных, которые могут изменять состояние сервера (например, добавление записи в БД, отправка формы).
        *   Запросы с POST обычно не кэшируются.
        *   Нельзя просто добавить в закладки (повторная отправка формы может вызвать предупреждение в браузере).
    *   В PHP данные доступны через суперглобальный массив `$_POST`.

3.  **Другие методы:**
    *   **PUT:** Используется для загрузки/полного обновления ресурса на сервере по указанному URI.
    *   **DELETE:** Используется для удаления ресурса на сервере.
    *   **HEAD:** Аналогичен GET, но сервер возвращает только заголовки, без тела ответа. Используется для проверки существования ресурса или получения метаданных.
    *   **OPTIONS:** Запрашивает информацию о доступных опциях связи для ресурса (например, какие методы HTTP поддерживаются).
    *   **PATCH:** Используется для частичного обновления ресурса.

В PHP для доступа к данным из разных источников используются суперглобальные массивы:
*   `$_GET`: данные из строки запроса URL.
*   `$_POST`: данные из тела POST-запроса.
*   `$_REQUEST`: содержит значения `$_GET`, `$_POST` и `$_COOKIE`. Порядок объединения зависит от настройки `request_order` в `php.ini`. Использовать с осторожностью из-за возможной путаницы и проблем безопасности.
*   `$_FILES`: информация о загруженных файлах.

**Выполнение CGI-скриптов (Common Gateway Interface):**

*   **Понятие:** CGI — это стандартный протокол (интерфейс), который определяет, как веб-сервер взаимодействует с внешними программами (скриптами) для генерации динамического контента. Скрипт, написанный на любом языке программирования (Perl, Python, C, PHP и т.д.), может быть CGI-скриптом.
*   **Процесс выполнения:**
    1.  Клиент (браузер) запрашивает URL, указывающий на CGI-скрипт.
    2.  Веб-сервер получает запрос.
    3.  Веб-сервер идентифицирует, что запрашиваемый ресурс является CGI-скриптом.
    4.  Веб-сервер подготавливает окружение для скрипта:
        *   Данные из HTTP-запроса (например, query string, данные POST, HTTP-заголовки) передаются скрипту через **переменные окружения** (например, `QUERY_STRING`, `REQUEST_METHOD`, `CONTENT_TYPE`, `CONTENT_LENGTH`, `HTTP_USER_AGENT`).
        *   POST-данные передаются скрипту через стандартный ввод (stdin).
    5.  Веб-сервер запускает CGI-скрипт как отдельный процесс.
    6.  CGI-скрипт выполняет свою логику, генерирует динамический контент.
    7.  Скрипт выводит результат на стандартный вывод (stdout). **Важно:** Первая часть вывода скрипта *должна* быть HTTP-заголовками, как минимум `Content-Type` (например, `Content-Type: text/html\n\n`), за которыми следует пустая строка, а затем тело ответа (HTML-страница, JSON и т.д.).
    8.  Веб-сервер перехватывает вывод скрипта (stdout).
    9.  Веб-сервер формирует полный HTTP-ответ на основе вывода скрипта и отправляет его клиенту.
    10. Процесс скрипта завершается.

*   **Недостатки традиционного CGI:**
    *   Запуск нового процесса для каждого запроса — это ресурсоемко и медленно, особенно при высокой нагрузке.
*   **Альтернативы/Улучшения:**
    *   **FastCGI:** Протокол, позволяющий держать процессы CGI-скриптов постоянно запущенными (пул процессов), что устраняет накладные расходы на создание процесса для каждого запроса. PHP-FPM (FastCGI Process Manager) — популярная реализация FastCGI для PHP, часто используется с Nginx.
    *   **Модули веб-сервера:** (например, `mod_php` для Apache). PHP-интерпретатор встраивается непосредственно в процесс веб-сервера. Это быстрее CGI, но может быть менее стабильно (ошибка в скрипте может повлиять на весь веб-сервер) и менее гибко в настройке.

Хотя PHP может работать как CGI-скрипт, современные конфигурации чаще используют FastCGI (с PHP-FPM) или модули веб-сервера.

---

### 3. Язык программирования PHP. Особенности синтаксиса.

**Язык программирования PHP (Hypertext Preprocessor):**

*   **Определение:** PHP — это широко используемый скриптовый язык программирования общего назначения с открытым исходным кодом, специально разработанный для веб-разработки. Он может встраиваться непосредственно в HTML-код.
*   **Ключевые характеристики:**
    *   **Серверный язык:** Код PHP выполняется на веб-сервере, а клиенту (браузеру) отправляется только результат его работы (обычно HTML, CSS, JavaScript, JSON, XML).
    *   **Динамическая типизация:** Типы переменных определяются во время выполнения, а не при объявлении.
    *   **Интерпретируемый:** Код PHP не компилируется в машинный код заранее, а интерпретируется "на лету" (хотя есть механизмы кэширования опкода, такие как OPcache).
    *   **C-подобный синтаксис:** Синтаксис во многом похож на C, Java, Perl, что облегчает его изучение для многих разработчиков.
    *   **Обширная стандартная библиотека:** Большое количество встроенных функций для работы с файлами, сетями, базами данных, строками, XML, JSON и т.д.
    *   **Хорошая интеграция с базами данных:** Поддерживает множество СУБД (MySQL, PostgreSQL, SQLite, MS SQL Server, Oracle и др.) через расширения вроде MySQLi, PDO.
    *   **Поддержка ООП:** Начиная с PHP 5, язык получил развитые возможности объектно-ориентированного программирования.
    *   **Кроссплатформенность:** Работает на большинстве операционных систем (Windows, Linux, macOS).
    *   **Открытый исходный код:** Бесплатен для использования и распространения.

**Особенности синтаксиса:**

1.  **Теги PHP:**
    *   Основной: `<?php ... ?>`
    *   Короткий тег echo: `<?= ... ?>` (эквивалентно `<?php echo ... ?>`, всегда доступен с PHP 5.4+)
    *   Короткие теги `<? ... ?>` (не рекомендуется, могут быть отключены директивой `short_open_tag`).
    *   Теги ASP `<% ... %>` (не рекомендуется, требуют включения `asp_tags`).

2.  **Комментарии:**
    *   Однострочные: `// Комментарий` или `# Комментарий`
    *   Многострочные: `/* Комментарий \n на несколько строк */`

3.  **Точка с запятой:** Каждая инструкция PHP должна заканчиваться точкой с запятой `;`.
    ```php
    echo "Привет";
    $x = 5 + 3;
    ```

4.  **Переменные:**
    *   Начинаются со знака доллара `$`.
    *   Имена переменных чувствительны к регистру (`$var` и `$VAR` — разные переменные).
    *   Не требуют предварительного объявления типа. Тип переменной определяется значением, которое ей присвоено.
    *   Пример: `$name = "Иван"; $age = 30; $isMarried = false;`

5.  **Типы данных:**
    *   Скалярные: `boolean`, `integer`, `float` (double), `string`.
    *   Составные: `array`, `object`.
    *   Специальные: `resource`, `null`.
    *   Псевдотипы: `mixed`, `number`, `callback`, `void`.

6.  **Строки:**
    *   Одинарные кавычки (`'строка'`): Содержимое обрабатывается буквально, переменные и управляющие последовательности (кроме `\'` и `\\`) не интерполируются.
    *   Двойные кавычки (`"строка"`): Переменные (`$var`) и управляющие последовательности (например, `\n`, `\t`) интерполируются.
    *   Heredoc и Nowdoc синтаксис для многострочных строк.
    *   Конкатенация строк: оператор `.` (точка). Пример: `$fullName = $firstName . " " . $lastName;`

7.  **Массивы:**
    *   Упорядоченные отображения (карты), которые связывают значения с ключами.
    *   Ключи могут быть целыми числами (индексные массивы) или строками (ассоциативные массивы).
    *   Создание: `array()` или короткий синтаксис `[]` (с PHP 5.4+).
    *   Примеры:
        ```php
        $numbers = [1, 2, 3]; // Индексный
        $person = ['name' => 'Анна', 'age' => 25]; // Ассоциативный
        echo $numbers[0]; // 1
        echo $person['name']; // Анна
        ```

8.  **Операторы:**
    *   Арифметические: `+`, `-`, `*`, `/`, `%` (остаток от деления), `**` (возведение в степень).
    *   Присваивания: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `.=`.
    *   Сравнения: `==`, `===` (тождественно равно, с учетом типа), `!=` (`<>`), `!==`, `<`, `>`, `<=`, `>=`.
    *   Логические: `&&` (и), `||` (или), `!` (не), `and`, `or`, `xor`.
    *   Инкремент/декремент: `++$a`, `$a++`, `--$a`, `$a--`.
    *   Тернарный оператор: `(условие) ? значение_если_true : значение_если_false;`
    *   Оператор объединения с null (Null coalescing operator, с PHP 7.0): `$variable = $value_might_be_null ?? 'default_value';`

9.  **Управляющие конструкции:**
    *   Условия: `if`, `elseif`, `else`.
    *   Переключатель: `switch`, `case`, `break`, `default`.
    *   Циклы: `for`, `while`, `do...while`, `foreach` (для перебора массивов и объектов).
    *   `break` (прерывание цикла), `continue` (переход к следующей итерации).

10. **Функции:**
    *   Объявление: `function имяФункции($параметр1, $параметр2 = 'значение по умолчанию') { // тело функции; return $результат; }`
    *   Имена функций нечувствительны к регистру (но рекомендуется придерживаться одного стиля).

11. **Чувствительность к регистру:**
    *   Имена переменных: чувствительны (`$myVar` != `$myvar`).
    *   Имена функций, классов, методов классов, констант (по умолчанию): нечувствительны (`myFunction()` и `MYFUNCTION()` вызовут одну и ту же функцию). Однако, рекомендуется придерживаться одного стиля (например, camelCase для функций и методов, PascalCase для классов).

12. **Вывод данных:**
    *   `echo`: выводит одну или несколько строк. Не является функцией, а конструкцией языка.
    *   `print`: выводит строку и всегда возвращает 1. Является конструкцией языка.
    *   `printf`, `sprintf`: для форматированного вывода.
    *   `var_dump`, `print_r`: для отладочного вывода информации о переменных, особенно массивов и объектов.

---

### 4. Обработка входных данных. Заголовки и ответ клиенту.

**Обработка входных данных:**

Это один из важнейших аспектов веб-разработки, так как некорректная обработка может привести к ошибкам в приложении и серьезным уязвимостям (XSS, SQL Injection и др.). **Никогда не доверяйте данным, приходящим от клиента!**

1.  **Источники входных данных:**
    *   `$_GET`: Данные из URL (query string).
    *   `$_POST`: Данные из тела POST-запроса (обычно из HTML-форм).
    *   `$_REQUEST`: Объединение `$_GET`, `$_POST`, `$_COOKIE`. Использовать с осторожностью.
    *   `$_FILES`: Информация о загруженных файлах.
    *   `$_COOKIE`: Данные из HTTP-куки.
    *   `$_SERVER`: Информация от веб-сервера (например, `HTTP_USER_AGENT`, `REMOTE_ADDR`).
    *   HTTP-заголовки запроса.

2.  **Этапы обработки:**
    *   **Проверка существования (isset, empty):** Прежде чем использовать данные, убедитесь, что они были переданы.
        ```php
        if (isset($_POST['username'])) {
            $username = $_POST['username'];
        } else {
            // Обработка случая, когда 'username' не передан
            $username = ''; // или ошибка
        }
        // С PHP 7.0+ можно использовать null coalescing operator:
        $username = $_POST['username'] ?? '';
        ```
    *   **Валидация:** Проверка данных на соответствие ожидаемому формату, типу, диапазону значений.
        *   **Тип:** `is_numeric()`, `is_string()`, `is_array()`, etc.
        *   **Формат:** Регулярные выражения (`preg_match()`) для email, телефона, URL и т.д.
        *   **Встроенные фильтры (Filter Functions):** `filter_var()`, `filter_input()`. Это предпочтительный способ.
            ```php
            $email = $_POST['email'] ?? '';
            if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
                // Некорректный email
            }

            $age = $_POST['age'] ?? 0;
            if (!filter_var($age, FILTER_VALIDATE_INT, ['options' => ['min_range' => 18, 'max_range' => 99]])) {
                // Некорректный возраст
            }
            ```
        *   **Диапазон:** Проверка, что число находится в допустимых пределах.
        *   **Длина:** Проверка длины строки (`strlen()`).
        *   **Обязательные поля:** Проверка, что поле не пустое (после `trim()`).
    *   **Очистка (Sanitization/Escaping):** Модификация данных для безопасного использования в различных контекстах.
        *   **Для вывода в HTML (предотвращение XSS - Cross-Site Scripting):**
            *   `htmlspecialchars($data, ENT_QUOTES, 'UTF-8')`: Преобразует специальные символы (`&`, `<`, `>`, `"`, `'`) в их HTML-сущности.
            *   `htmlentities()`: Преобразует все символы, имеющие HTML-сущности.
        *   **Для использования в SQL-запросах (предотвращение SQL Injection):** Использовать **подготовленные выражения (prepared statements)** с PDO или MySQLi. Это лучший метод. Если это невозможно, то `mysqli_real_escape_string()` или `PDO::quote()`.
        *   **Для использования в URL:** `urlencode()`, `rawurlencode()`.
        *   **Для использования в командной строке:** `escapeshellarg()`, `escapeshellcmd()`.
        *   **Удаление нежелательных тегов:** `strip_tags($text, '<p><a>')` (оставляет только теги `<p>` и `<a>`).

**Заголовки и ответ клиенту:**

После обработки запроса и выполнения логики PHP-скрипт формирует ответ клиенту. Этот ответ состоит из HTTP-заголовков и тела ответа.

1.  **Отправка HTTP-заголовков:**
    *   Заголовки должны быть отправлены **до** любого вывода тела ответа (HTML, echo, пробелы перед `<?php`).
    *   Функция `header("Строка заголовка")`:
        ```php
        // Установка типа контента и кодировки
        header("Content-Type: text/html; charset=UTF-8");

        // Редирект на другую страницу
        header("Location: http://www.example.com/new_page.php");
        exit; // Важно! Прекратить выполнение скрипта после редиректа.

        // Установка кода ответа (например, 404 Not Found)
        header("HTTP/1.1 404 Not Found");
        // или с PHP 5.4+
        http_response_code(404);

        // Управление кэшированием
        header("Cache-Control: no-cache, must-revalidate");
        header("Expires: Sat, 26 Jul 1997 05:00:00 GMT"); // Дата в прошлом

        // Отправка файла на скачивание
        header('Content-Disposition: attachment; filename="downloaded.pdf"');
        header('Content-Type: application/pdf');
        // readfile('path/to/file.pdf');
        ```
    *   Функция `headers_sent(&$file, &$line)`: Проверяет, были ли уже отправлены заголовки. Если да, то `$file` и `$line` будут содержать имя файла и номер строки, где начался вывод.
    *   Функция `setcookie()` также отправляет HTTP-заголовок (`Set-Cookie`) и должна вызываться до вывода тела.

2.  **Отправка тела ответа:**
    *   Все, что выводится PHP-скриптом после отправки заголовков (или если заголовки не отправляются явно, то после того, как PHP отправит их по умолчанию), становится телом HTTP-ответа.
    *   Используются конструкции `echo`, `print`, `printf()`.
    *   HTML-код вне тегов `<?php ... ?>` также является частью тела ответа.
        ```php
        <?php
        // ... PHP-код ...
        header("Content-Type: application/json; charset=UTF-8");
        $data = ['status' => 'success', 'message' => 'Данные обработаны'];
        echo json_encode($data); // Тело ответа - JSON
        ?>
        ```
        Или:
        ```php
        <?php
        $pageTitle = "Моя страница";
        // Заголовки будут отправлены автоматически перед первым HTML
        ?>
        <!DOCTYPE html>
        <html>
        <head>
            <title><?php echo htmlspecialchars($pageTitle); ?></title>
        </head>
        <body>
            <h1>Привет, мир!</h1>
            <p>Это тело HTML-ответа.</p>
        </body>
        </html>
        ```

**Буферизация вывода (Output Buffering):**
Позволяет собирать весь вывод скрипта в буфер, прежде чем он будет отправлен клиенту. Это полезно, если нужно отправить заголовки после того, как какой-то вывод уже был сгенерирован.
```php
ob_start(); // Включить буферизацию вывода

echo "Какой-то контент.";

// ... позже в коде ...
header("X-Custom-Header: MyValue"); // Теперь это сработает, т.к. вывод в буфере

ob_end_flush(); // Отправить содержимое буфера клиенту и отключить буферизацию
// или ob_end_clean(); // Очистить буфер без отправки и отключить буферизацию
```

---

### 5. Операторы включения (include, require). Пользовательские функции в PHP.

**Операторы включения (include, require):**

Эти конструкции языка PHP используются для включения и выполнения содержимого другого PHP-файла в текущем скрипте. Это основной механизм для организации кода, переиспользования компонентов (например, шапки, подвала сайта, конфигурационных файлов, библиотек функций).

1.  **`include 'filename.php';`**
    *   Включает и выполняет указанный файл.
    *   Если файл не найден, `include` генерирует **предупреждение (E_WARNING)**, но выполнение скрипта **продолжается**.
    *   Если во включенном файле есть оператор `return`, то `include` вернет значение этого `return`. Если `return` нет, вернет `1` при успешном включении.

2.  **`require 'filename.php';`**
    *   Включает и выполняет указанный файл.
    *   Если файл не найден, `require` генерирует **фатальную ошибку (E_COMPILE_ERROR)**, и выполнение скрипта **прекращается**.
    *   Используется для критически важных файлов, без которых приложение не может функционировать (например, файлы конфигурации, основные классы).

3.  **`include_once 'filename.php';`**
    *   Аналогичен `include`, но PHP проверяет, был ли этот файл уже включен ранее в ходе выполнения скрипта. Если да, то повторное включение **не происходит**.
    *   Это предотвращает проблемы, связанные с повторным определением функций, классов или констант.

4.  **`require_once 'filename.php';`**
    *   Аналогичен `require`, но PHP также проверяет, был ли файл уже включен. Если да, повторное включение не происходит.
    *   Используется для критически важных файлов, которые должны быть включены только один раз.

**Пример использования:**
```php
// config.php
<?php
define('DB_HOST', 'localhost');
define('DB_USER', 'root');
// ...
?>

// header.php
<!DOCTYPE html>
<html>
<head><title>Мой сайт</title></head>
<body>
<header><h1>Шапка сайта</h1></header>

// index.php
<?php
require_once 'config.php'; // Критически важно, подключить один раз
include 'header.php';     // Шапка, если не найдется - не фатально (хотя обычно тоже require_once)
?>
<main>
    <p>Основное содержимое страницы.</p>
    <?php
    // ...
    $value = include 'data_source.php'; // Файл может вернуть данные
    var_dump($value);
    ?>
</main>
<?php
include 'footer.php';
?>
```
**Поиск файлов:** PHP ищет включаемые файлы сначала в путях, указанных в директиве `include_path` (php.ini), а затем в директории текущего скрипта. Можно указывать абсолютные или относительные пути.

**Пользовательские функции в PHP:**

Функции — это именованные блоки кода, которые выполняют определенную задачу и могут быть вызваны многократно из разных частей программы.

1.  **Объявление функции:**
    ```php
    function имяФункции(тип $параметр1, тип $параметр2 = 'значение_по_умолчанию', ...): типВозврата
    {
        // Тело функции: набор инструкций
        // ...
        return $результат; // Необязательно, если функция ничего не возвращает (void)
    }
    ```
    *   **`function`**: Ключевое слово для объявления функции.
    *   **`имяФункции`**: Имя должно начинаться с буквы или подчеркивания, за которыми могут следовать буквы, цифры или подчеркивания. Имена функций нечувствительны к регистру, но принято использовать camelCase (`myFunction`) или snake_case (`my_function`).
    *   **`$параметр1, $параметр2`**: Список параметров (аргументов), которые функция принимает.
        *   **Тип параметра (Type Hinting, с PHP 5, расширено в PHP 7+):** Можно указывать ожидаемый тип параметра (`int`, `string`, `array`, `ClassName`, `iterable`, `object`, etc.). PHP попытается привести тип или выбросит `TypeError`.
        *   **Значение по умолчанию:** Параметру можно присвоить значение по умолчанию. Такие параметры должны идти после обязательных.
        *   **Передача по ссылке:** `&$параметр` - изменения параметра внутри функции отразятся на переменной, переданной в функцию.
        *   **Переменное число аргументов (Variadic functions, с PHP 5.6+):** `...$args` - все оставшиеся аргументы будут собраны в массив `$args`.
    *   **`типВозврата (Return Type Declaration, с PHP 7+):`** Можно указать тип значения, которое функция должна вернуть (`: int`, `: string`, `: void` (если ничего не возвращает), `: ClassName`, etc.).
    *   **`return $результат;`**: Возвращает значение из функции. Если `return` отсутствует или используется без значения (`return;`), функция вернет `NULL`.

2.  **Вызов функции:**
    ```php
    $результат = имяФункции($аргумент1, $аргумент2);
    имяФункции('значение'); // Если не нужно возвращаемое значение
    ```

3.  **Область видимости переменных:**
    *   Переменные, объявленные внутри функции, являются **локальными** и доступны только внутри этой функции.
    *   Чтобы получить доступ к глобальной переменной изнутри функции, нужно использовать ключевое слово `global` или суперглобальный массив `$GLOBALS`.
        ```php
        $globalVar = 10;
        function testScope() {
            global $globalVar;
            $localVar = 5;
            echo $globalVar; // 10
            echo $GLOBALS['globalVar']; // 10
        }
        // echo $localVar; // Ошибка: undefined variable
        ```

4.  **Анонимные функции (замыкания, Closures, с PHP 5.3+):**
    Функции без имени. Могут быть присвоены переменным, переданы как аргументы другим функциям. Могут "захватывать" переменные из внешней области видимости с помощью `use`.
    ```php
    $message = "Привет";
    $sayHello = function($name) use ($message) {
        echo "$message, $name!";
    };
    $sayHello("Мир"); // Выведет: Привет, Мир!
    ```

5.  **Стрелочные функции (Arrow Functions, с PHP 7.4+):**
    Краткий синтаксис для анонимных функций, которые возвращают одно выражение. Автоматически захватывают переменные из внешней области видимости.
    ```php
    $factor = 2;
    $multiply = fn($number) => $number * $factor;
    echo $multiply(5); // 10
    ```

**Пример пользовательской функции:**
```php
/**
 * Суммирует два числа.
 *
 * @param int $a Первое число.
 * @param int $b Второе число.
 * @return int Сумма чисел.
 */
function addNumbers(int $a, int $b = 0): int
{
    return $a + $b;
}

$sum1 = addNumbers(5, 3); // $sum1 = 8
$sum2 = addNumbers(10);   // $sum2 = 10 (т.к. $b по умолчанию 0)
echo "Сумма: " . $sum1;
```

---

### 6. Классы и объекты. Использование свойств и методов объекта.

**Классы и объекты (Основы ООП в PHP):**

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции "объектов", которые могут содержать данные в виде полей (часто известных как атрибуты или **свойства**) и код в виде процедур (часто известных как **методы**).

*   **Класс (Class):**
    *   Это "чертеж" или шаблон для создания объектов.
    *   Определяет структуру (свойства) и поведение (методы), которые будут у всех объектов этого класса.
    *   Объявляется с помощью ключевого слова `class`.
    ```php
    class Car
    {
        // Тело класса
    }
    ```

*   **Объект (Object):**
    *   Это конкретный экземпляр класса.
    *   Создается с помощью оператора `new`.
    *   Каждый объект имеет свои собственные значения свойств, но разделяет методы с другими объектами того же класса.
    ```php
    $myCar = new Car(); // $myCar - это объект (экземпляр) класса Car
    $anotherCar = new Car();
    ```

**Свойства объекта (Properties / Attributes):**

*   Это переменные, объявленные внутри класса. Они хранят данные, относящиеся к объекту.
*   Объявляются с модификаторами доступа (`public`, `protected`, `private`) и, опционально, с типом (с PHP 7.4+).
    ```php
    class Car
    {
        public string $color;       // Свойство "цвет", доступно отовсюду
        protected string $engineType; // Доступно внутри класса и его наследников
        private int $mileage = 0;  // Доступно только внутри этого класса, начальное значение 0

        // С PHP 7.4+ можно указывать тип
        public ?string $model = null; // Может быть string или null
    }
    ```
*   **Доступ к свойствам:**
    *   Внутри методов класса: с помощью псевдо-переменной `$this->propertyName`.
    *   Снаружи класса (для `public` свойств): с помощью оператора `->` (стрелка): `$object->propertyName`.
    ```php
    $myCar = new Car();
    $myCar->color = "Красный"; // Установка значения public свойства
    echo $myCar->color;       // Чтение значения public свойства
    ```

**Методы объекта (Methods):**

*   Это функции, объявленные внутри класса. Они определяют поведение объекта.
*   Объявляются с модификаторами доступа (`public`, `protected`, `private`).
    ```php
    class Car
    {
        public string $color = 'Белый';
        private int $mileage = 0;

        // Метод для установки пробега
        public function setMileage(int $km): void
        {
            if ($km >= $this->mileage) { // $this ссылается на текущий объект
                $this->mileage = $km;
            }
        }

        // Метод для получения пробега
        public function getMileage(): int
        {
            return $this->mileage;
        }

        public function drive(int $distance): void
        {
            if ($distance > 0) {
                $this->mileage += $distance;
                echo "Машина проехала {$distance} км. Общий пробег: {$this->mileage} км.<br>";
            }
        }
    }
    ```
*   **Доступ к методам:**
    *   Внутри других методов того же класса: `$this->methodName()`.
    *   Снаружи класса (для `public` методов): `$object->methodName()`.
    ```php
    $myCar = new Car();
    $myCar->color = "Синий";
    $myCar->setMileage(10000);
    $myCar->drive(50); // Машина проехала 50 км. Общий пробег: 10050 км.
    echo "Текущий пробег: " . $myCar->getMileage(); // Текущий пробег: 10050
    ```

**`$this`:**
*   Специальная псевдо-переменная, доступная внутри методов объекта.
*   Она ссылается на **текущий экземпляр объекта**, из которого вызывается метод.
*   Используется для доступа к свойствам (`$this->property`) и другим методам (`$this->method()`) того же объекта.

**Конструктор (`__construct`):**
*   Специальный метод, который автоматически вызывается при создании нового объекта с помощью `new`.
*   Используется для инициализации свойств объекта.
    ```php
    class User
    {
        public string $username;
        public string $email;

        public function __construct(string $username, string $email)
        {
            $this->username = $username;
            $this->email = $email;
            echo "Пользователь {$this->username} создан.<br>";
        }
    }
    $user1 = new User("john_doe", "john@example.com"); // Автоматически вызовет __construct
    ```
*   **С PHP 8.0+ доступно продвижение свойств конструктора (constructor property promotion):**
    ```php
    class UserNew
    {
        public function __construct(
            public string $username, // Автоматически создаст свойство $username
            public string $email     // и присвоит ему значение
        ) {
            echo "Пользователь {$this->username} создан.<br>";
        }
    }
    $user2 = new UserNew("jane_doe", "jane@example.com");
    echo $user2->email; // jane@example.com
    ```

**Деструктор (`__destruct`):**
*   Специальный метод, который автоматически вызывается, когда объект больше не используется (например, при завершении скрипта или когда на него нет ссылок и сборщик мусора его удаляет).
*   Используется для освобождения ресурсов, закрытия файлов и т.д.
    ```php
    class FileManager
    {
        private $fileHandle;

        public function __construct(string $filename)
        {
            $this->fileHandle = fopen($filename, 'w');
            echo "Файл открыт.<br>";
        }

        public function __destruct()
        {
            if ($this->fileHandle) {
                fclose($this->fileHandle);
            }
            echo "Файл закрыт, объект FileManager уничтожен.<br>";
        }
    }
    $fm = new FileManager("test.txt");
    // ... работа с $fm ...
    // __destruct будет вызван автоматически при завершении скрипта или когда $fm будет уничтожен
    ```

**Модификаторы доступа:**
*   `public`: Свойство или метод доступен отовсюду (из самого класса, из дочерних классов, извне класса).
*   `protected`: Свойство или метод доступен из самого класса и из его дочерних классов (классов-наследников). Недоступен извне.
*   `private`: Свойство или метод доступен только изнутри того класса, в котором он объявлен. Недоступен даже для дочерних классов.

**Статические свойства и методы (`static`):**
*   Принадлежат классу, а не конкретному объекту.
*   Доступ к ним осуществляется через имя класса и оператор `::` (двойное двоеточие): `ClassName::$staticProperty`, `ClassName::staticMethod()`.
*   Внутри статических методов нельзя использовать `$this`, так как они не привязаны к экземпляру объекта.
*   Для доступа к статическим членам изнутри класса используется `self::` или `static::` (для позднего статического связывания).
    ```php
    class MathUtils
    {
        public static float $pi = 3.14159;

        public static function add(int $a, int $b): int
        {
            return $a + $b;
        }
    }
    echo MathUtils::$pi; // 3.14159
    echo MathUtils::add(5, 7); // 12
    ```

---

### 7. Регулярные выражения. Манипуляции с текстом.

**Регулярные выражения (Regular Expressions, Regex):**

*   **Понятие:** Это последовательность символов, которая определяет шаблон поиска. Регулярные выражения используются для поиска, сопоставления, замены и извлечения частей строк на основе этих шаблонов.
*   PHP использует библиотеку PCRE (Perl Compatible Regular Expressions), которая предоставляет мощный и гибкий синтаксис.

**Основные функции PHP для работы с PCRE:**

*   **`preg_match($pattern, $subject, &$matches = null, $flags = 0, $offset = 0)`:**
    *   Ищет в строке `$subject` совпадение с шаблоном `$pattern`.
    *   Возвращает `1`, если совпадение найдено, `0` — если нет, `false` — при ошибке.
    *   Если передан массив `$matches`, он будет заполнен результатами поиска: `$matches[0]` содержит всю совпавшую строку, `$matches[1]` — первую захваченную подстроку (в скобках), и т.д.
*   **`preg_match_all($pattern, $subject, &$matches = null, $flags = PREG_PATTERN_ORDER, $offset = 0)`:**
    *   Ищет в строке `$subject` все совпадения с шаблоном `$pattern` и помещает их в массив `$matches`.
    *   Возвращает количество найденных совпадений (может быть `0`) или `false` при ошибке.
*   **`preg_replace($pattern, $replacement, $subject, $limit = -1, &$count = null)`:**
    *   Ищет в строке `$subject` совпадения с шаблоном `$pattern` и заменяет их на строку `$replacement`.
    *   `$replacement` может содержать обратные ссылки на захваченные группы (например, `$1`, `${1}`).
    *   Возвращает измененную строку (или массив строк, если `$subject` был массивом).
*   **`preg_split($pattern, $subject, $limit = -1, $flags = 0)`:**
    *   Разбивает строку `$subject` на массив по разделителю, заданному шаблоном `$pattern`.
*   **`preg_grep($pattern, $input_array, $flags = 0)`:**
    *   Возвращает массив, состоящий из элементов массива `$input_array`, которые соответствуют шаблону `$pattern`.

**Синтаксис регулярных выражений (основы):**

1.  **Ограничители (Delimiters):** Шаблон заключается в ограничители. Чаще всего `/`, но могут быть и другие (например, `#`, `~`, `!`).
    Пример: `/шаблон/`
2.  **Модификаторы:** Ставятся после закрывающего ограничителя.
    *   `i`: Регистронезависимый поиск.
    *   `m`: Многострочный режим (`^` и `$` совпадают с началом/концом каждой строки).
    *   `s`: Режим "dotall" (точка `.` совпадает также с символами новой строки `\n`).
    *   `u`: Обрабатывать шаблон и строку как UTF-8 (важно для кириллицы и других не-ASCII символов).
    Пример: `/шаблон/imu`
3.  **Метасимволы (специальные символы):**
    *   `.` : Любой символ (кроме новой строки, если не включен модификатор `s`).
    *   `^` : Начало строки (или начало строки в многострочном режиме `m`).
    *   `$` : Конец строки (или конец строки в многострочном режиме `m`).
    *   `\` : Экранирование следующего символа (например, `\.` означает буквальную точку).
4.  **Квантификаторы (повторения):**
    *   `*` : 0 или более раз.
    *   `+` : 1 или более раз.
    *   `?` : 0 или 1 раз.
    *   `{n}` : Ровно `n` раз.
    *   `{n,}` : `n` или более раз.
    *   `{n,m}` : От `n` до `m` раз.
    *   По умолчанию квантификаторы "жадные" (захватывают как можно больше). Добавление `?` после квантификатора делает его "ленивым" (захватывает как можно меньше): `*?`, `+?`, `??`, `{n,}?`.
5.  **Символьные классы:**
    *   `[abc]` : Один из символов: `a`, `b` или `c`.
    *   `[^abc]` : Любой символ, кроме `a`, `b`, `c`.
    *   `[a-z]` : Любая строчная латинская буква.
    *   `[0-9]` : Любая цифра.
    *   Предопределенные классы:
        *   `\d` : Любая цифра (`[0-9]`).
        *   `\D` : Любой нецифровой символ.
        *   `\w` : Любой "словесный" символ (буква, цифра или `_`). Для кириллицы нужен модификатор `u`.
        *   `\W` : Любой не "словесный" символ.
        *   `\s` : Любой пробельный символ (пробел, таб, новая строка и т.д.).
        *   `\S` : Любой непробельный символ.
6.  **Группировка и захват:**
    *   `( )` : Группирует часть шаблона и захватывает совпавшую подстроку.
    *   `(?: )` : Группировка без захвата.
7.  **Альтернатива (ИЛИ):**
    *   `|` : Оператор ИЛИ. `cat|dog` совпадает с "cat" или "dog".

**Примеры использования:**
```php
// Проверка email
$email = "test@example.com";
if (preg_match('/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/u', $email)) {
    echo "Email корректен.<br>";
}

// Извлечение чисел из строки
$text = "Цена: 123 руб., скидка 15%";
preg_match_all('/\d+/', $text, $matches);
print_r($matches[0]); // Array ( [0] => 123 [1] => 15 )
echo "<br>";

// Замена всех пробельных последовательностей на один пробел
$str = "Это    строка  с   лишними   пробелами.";
$cleanStr = preg_replace('/\s+/', ' ', $str);
echo $cleanStr . "<br>"; // Это строка с лишними пробелами.
```

**Манипуляции с текстом (стандартные строковые функции PHP):**

Помимо регулярных выражений, PHP предоставляет множество встроенных функций для работы со строками.

*   **Длина строки:** `strlen($str)` (возвращает количество байт, для UTF-8 `mb_strlen($str)`).
*   **Поиск подстроки:**
    *   `strpos($haystack, $needle)`: Позиция первого вхождения `$needle` в `$haystack` (регистрозависимый).
    *   `stripos($haystack, $needle)`: То же, но регистронезависимый.
    *   `strrpos()`, `strripos()`: Поиск последнего вхождения.
    *   `strstr()`, `stristr()`: Находит первое вхождение подстроки и возвращает часть строки, начиная с этого вхождения.
*   **Замена подстроки:**
    *   `str_replace($search, $replace, $subject)`: Заменяет все вхождения `$search` на `$replace` в `$subject` (регистрозависимый).
    *   `str_ireplace()`: То же, но регистронезависимый.
*   **Извлечение подстроки:**
    *   `substr($string, $start, $length = null)`: Возвращает часть строки. Для UTF-8 `mb_substr()`.
*   **Разбиение строки на массив:**
    *   `explode($delimiter, $string)`: Разбивает строку по разделителю `$delimiter`.
*   **Объединение массива в строку:**
    *   `implode($glue, $pieces_array)` (или `join()`).
*   **Изменение регистра:**
    *   `strtolower($str)`: В нижний регистр.
    *   `strtoupper($str)`: В верхний регистр.
    *   `ucfirst($str)`: Первый символ в верхний регистр.
    *   `ucwords($str)`: Первые символы каждого слова в верхний регистр.
    *   Для UTF-8 используйте `mb_strtolower()`, `mb_strtoupper()`, etc.
*   **Удаление пробелов:**
    *   `trim($str, $charlist = " \t\n\r\0\x0B")`: Удаляет пробелы (или другие символы из `$charlist`) с начала и конца строки.
    *   `ltrim()`: Слева.
    *   `rtrim()`: Справа.
*   **Форматирование строк:**
    *   `sprintf($format, ...$args)`: Возвращает отформатированную строку.
    *   `printf($format, ...$args)`: Выводит отформатированную строку.
*   **Работа с HTML:**
    *   `htmlspecialchars($string, ENT_QUOTES | ENT_HTML5, 'UTF-8')`: Преобразует специальные символы в HTML-сущности (защита от XSS).
    *   `htmlentities()`: Преобразует все подходящие символы в HTML-сущности.
    *   `strip_tags($string, $allowed_tags = null)`: Удаляет HTML и PHP теги.
*   **Сравнение строк:**
    *   `strcmp($str1, $str2)`: Бинарно безопасное сравнение строк (регистрозависимое).
    *   `strcasecmp()`: Регистронезависимое.
*   **И другие:** `str_pad()`, `str_repeat()`, `strrev()`, `nl2br()`, etc.

При работе с многобайтными кодировками (например, UTF-8, что актуально для русского языка) следует использовать функции из расширения `mbstring` (например, `mb_strlen`, `mb_substr`, `mb_strtolower`), предварительно убедившись, что это расширение установлено и настроено (`mb_internal_encoding('UTF-8');`).

---

### 8. Работа с текстовыми файлами.

PHP предоставляет богатый набор функций для работы с файловой системой и файлами. Основные операции: чтение, запись, создание, удаление, проверка существования и т.д.

**Основные функции для работы с файлами:**

1.  **Открытие и закрытие файлов:**
    *   `fopen($filename, $mode, $use_include_path = false, $context = null)`: Открывает файл или URL.
        *   `$filename`: Путь к файлу.
        *   `$mode`: Режим открытия файла:
            *   `'r'`: Только для чтения. Указатель в начало файла.
            *   `'r+'`: Для чтения и записи. Указатель в начало файла.
            *   `'w'`: Только для записи. Указатель в начало файла, **содержимое файла усекается (удаляется)**. Если файл не существует, пытается его создать.
            *   `'w+'`: Для чтения и записи. Указатель в начало, содержимое усекается. Если не существует, пытается создать.
            *   `'a'`: Только для записи (добавление). Указатель в конец файла. Если не существует, пытается создать.
            *   `'a+'`: Для чтения и записи (добавление). Указатель в конец. Если не существует, пытается создать.
            *   `'x'`: Только для записи. Создает новый файл. Если файл уже существует, `fopen()` вернет `false` и сгенерирует ошибку уровня `E_WARNING`.
            *   `'x+'`: Для чтения и записи. Аналогично `'x'`.
            *   Можно добавить `'b'` к режиму для бинарного режима (например, `'rb'`, `'wb'`). Важно для Windows.
        *   Возвращает файловый дескриптор (ресурс) при успехе или `false` при ошибке.
    *   `fclose($handle)`: Закрывает открытый файловый дескриптор. **Очень важно всегда закрывать файлы после использования.**

2.  **Чтение из файла:**
    *   `fread($handle, $length)`: Читает до `$length` байт из файла, на который указывает `$handle`.
    *   `fgets($handle, $length = null)`: Читает строку из файла (до символа новой строки, до конца файла или до `$length - 1` байт).
    *   `fgetc($handle)`: Читает один символ из файла.
    *   `feof($handle)`: Проверяет, достигнут ли конец файла (`EOF`).
    *   `file_get_contents($filename, ...)`: Читает все содержимое файла в строку. Удобно, но **осторожно с большими файлами**, т.к. весь файл загружается в память.
    *   `file($filename, $flags = 0, $context = null)`: Читает весь файл в массив, где каждый элемент — это строка файла. Также осторожно с большими файлами.
    *   `readfile($filename)`: Читает файл и выводит его в выходной поток.

3.  **Запись в файл:**
    *   `fwrite($handle, $string, $length = null)` (или `fputs`): Записывает строку `$string` в файл.
    *   `file_put_contents($filename, $data, $flags = 0, $context = null)`: Записывает данные (строку или массив) в файл. Если файл не существует, он будет создан. Если существует, его содержимое будет перезаписано по умолчанию.
        *   `FILE_APPEND`: Флаг для добавления данных в конец файла вместо перезаписи.
        *   `LOCK_EX`: Флаг для эксклюзивной блокировки файла во время записи.

4.  **Управление указателем файла:**
    *   `fseek($handle, $offset, $whence = SEEK_SET)`: Перемещает указатель файла.
        *   `SEEK_SET`: Установить позицию на `$offset` байт от начала файла.
        *   `SEEK_CUR`: Установить позицию на `$offset` байт от текущей позиции.
        *   `SEEK_END`: Установить позицию на `$offset` байт от конца файла (отрицательный `$offset` для смещения назад).
    *   `ftell($handle)`: Возвращает текущую позицию указателя файла.
    *   `rewind($handle)`: Перемещает указатель файла в начало.

5.  **Проверки и информация о файлах:**
    *   `file_exists($filename)`: Проверяет, существует ли файл или директория.
    *   `is_file($filename)`: Проверяет, является ли путь файлом.
    *   `is_dir($filename)`: Проверяет, является ли путь директорией.
    *   `is_readable($filename)`: Проверяет, доступен ли файл для чтения.
    *   `is_writable($filename)`: Проверяет, доступен ли файл для записи.
    *   `filesize($filename)`: Возвращает размер файла в байтах.
    *   `filemtime($filename)`: Возвращает время последнего изменения файла (Unix timestamp).
    *   `pathinfo($path, $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME)`: Возвращает информацию о пути к файлу.

6.  **Операции с файлами и директориями:**
    *   `copy($source, $dest)`: Копирует файл.
    *   `rename($oldname, $newname)`: Переименовывает или перемещает файл/директорию.
    *   `unlink($filename)`: Удаляет файл.
    *   `mkdir($pathname, $mode = 0777, $recursive = false)`: Создает директорию.
    *   `rmdir($dirname)`: Удаляет пустую директорию.

**Примеры:**

*   **Чтение файла построчно:**
    ```php
    $filename = "data.txt";
    if (file_exists($filename) && is_readable($filename)) {
        $handle = fopen($filename, "r");
        if ($handle) {
            while (($line = fgets($handle)) !== false) {
                // Обработка строки $line
                echo htmlspecialchars(trim($line)) . "<br>";
            }
            fclose($handle);
        } else {
            echo "Не удалось открыть файл.<br>";
        }
    } else {
        echo "Файл не найден или недоступен для чтения.<br>";
    }
    ```

*   **Запись (или перезапись) в файл:**
    ```php
    $filename = "output.txt";
    $data = "Это первая строка.\nЭто вторая строка.\n";
    $handle = fopen($filename, "w"); // 'w' - перезапишет файл
    if ($handle) {
        if (fwrite($handle, $data)) {
            echo "Данные успешно записаны в файл '$filename'.<br>";
        } else {
            echo "Ошибка записи в файл.<br>";
        }
        fclose($handle);
    } else {
        echo "Не удалось открыть файл '$filename' для записи.<br>";
    }
    ```

*   **Добавление в конец файла (логгирование):**
    ```php
    $logFile = "app.log";
    $logMessage = date("[Y-m-d H:i:s]") . " - Новое событие.\n";
    // Использование file_put_contents с флагом FILE_APPEND
    if (file_put_contents($logFile, $logMessage, FILE_APPEND | LOCK_EX) !== false) {
        echo "Сообщение добавлено в лог.<br>";
    } else {
        echo "Ошибка записи в лог-файл.<br>";
    }
    ```

**Блокировка файлов (`flock`):**
При одновременной работе нескольких процессов с одним файлом (особенно при записи) могут возникать конфликты. `flock($handle, $operation)` позволяет устанавливать блокировки:
*   `LOCK_SH`: Разделяемая блокировка (для чтения). Несколько процессов могут одновременно читать.
*   `LOCK_EX`: Эксклюзивная блокировка (для записи). Только один процесс может писать.
*   `LOCK_UN`: Снять блокировку.
*   `LOCK_NB`: Не блокировать при установке блокировки (если файл уже заблокирован, `flock` не будет ждать).

```php
$handle = fopen("critical_data.txt", "c"); // 'c' - открыть для записи, если нет - создать. Не усекает.
if (flock($handle, LOCK_EX)) { // Пытаемся установить эксклюзивную блокировку
    fwrite($handle, "Обновленные данные\n");
    fflush($handle); // Сбросить буфер вывода PHP в файл
    flock($handle, LOCK_UN); // Снять блокировку
} else {
    echo "Не удалось заблокировать файл для записи.";
}
fclose($handle);
```

---

### 9. Доступ к базе данных (MySQL). Обеспечение безопасности запросов к БД.

**Доступ к базе данных (MySQL):**

PHP предлагает несколько способов взаимодействия с базами данных MySQL:

1.  **MySQLi (MySQL Improved Extension):**
    *   Расширение, специфичное для MySQL.
    *   Поддерживает процедурный и объектно-ориентированный стили.
    *   Предлагает поддержку подготовленных выражений, транзакций, множественных запросов и др.
    *   Является рекомендованной заменой старого расширения `mysql` (которое удалено с PHP 7.0).

2.  **PDO (PHP Data Objects):**
    *   Предоставляет абстрактный слой для доступа к различным базам данных (MySQL, PostgreSQL, SQLite, MS SQL Server, Oracle и др.) через единый интерфейс.
    *   Использует только объектно-ориентированный стиль.
    *   Поддерживает подготовленные выражения, транзакции.
    *   **Предпочтительный способ** для новых проектов из-за гибкости (легче сменить СУБД) и консистентного API.

**Общий процесс работы с БД (на примере PDO и MySQLi OOP):**

1.  **Подключение к БД:**
    *   **PDO:**
        ```php
        $host = 'localhost';
        $db   = 'mydatabase';
        $user = 'root';
        $pass = 'password';
        $charset = 'utf8mb4';

        $dsn = "mysql:host=$host;dbname=$db;charset=$charset";
        $options = [
            PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION, // Выбрасывать исключения при ошибках
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,     // Режим выборки по умолчанию (ассоциативный массив)
            PDO::ATTR_EMULATE_PREPARES   => false,                // Использовать нативные подготовленные выражения
        ];

        try {
             $pdo = new PDO($dsn, $user, $pass, $options);
             // echo "Подключение успешно установлено!";
        } catch (\PDOException $e) {
             throw new \PDOException($e->getMessage(), (int)$e->getCode());
             // В реальном приложении: логировать ошибку, показать пользователю общее сообщение
        }
        ```
    *   **MySQLi (OOP):**
        ```php
        $host = 'localhost';
        $db   = 'mydatabase';
        $user = 'root';
        $pass = 'password';

        $mysqli = new mysqli($host, $user, $pass, $db);

        if ($mysqli->connect_error) {
            die("Ошибка подключения: " . $mysqli->connect_error);
            // В реальном приложении: логировать, показать общее сообщение
        }
        $mysqli->set_charset("utf8mb4"); // Установка кодировки
        // echo "Подключение успешно установлено!";
        ```

2.  **Выполнение SQL-запросов:**
    *   **SELECT (Выборка данных):**
        *   **PDO (с подготовленным выражением):**
            ```php
            $stmt = $pdo->prepare("SELECT id, name, email FROM users WHERE status = ? AND age > ?");
            $stmt->execute(['active', 25]); // Передача параметров
            // Получение всех строк
            $users = $stmt->fetchAll(); // PDO::FETCH_ASSOC по умолчанию из опций
            // Или получение по одной строке
            // while ($row = $stmt->fetch()) { /* ... */ }
            ```
        *   **MySQLi (OOP, с подготовленным выражением):**
            ```php
            $stmt = $mysqli->prepare("SELECT id, name, email FROM users WHERE status = ? AND age > ?");
            $status = 'active';
            $age = 25;
            $stmt->bind_param("si", $status, $age); // "s" - string, "i" - integer
            $stmt->execute();
            $result = $stmt->get_result(); // Получаем объект результата
            $users = $result->fetch_all(MYSQLI_ASSOC); // Все строки как ассоциативные массивы
            // Или по одной строке
            // while ($row = $result->fetch_assoc()) { /* ... */ }
            $stmt->close();
            ```
    *   **INSERT, UPDATE, DELETE (Изменение данных):**
        *   **PDO:**
            ```php
            $sql = "INSERT INTO users (name, email, status) VALUES (:name, :email, :status)";
            $stmt= $pdo->prepare($sql);
            $stmt->execute([
                'name' => 'Иван Иванов',
                'email' => 'ivan@example.com',
                'status' => 'active'
            ]);
            $lastInsertId = $pdo->lastInsertId(); // Получение ID последней вставленной записи
            $affectedRows = $stmt->rowCount(); // Количество затронутых строк
            ```
        *   **MySQLi (OOP):**
            ```php
            $sql = "INSERT INTO users (name, email, status) VALUES (?, ?, ?)";
            $stmt = $mysqli->prepare($sql);
            $name = 'Петр Петров';
            $email = 'petr@example.com';
            $status = 'pending';
            $stmt->bind_param("sss", $name, $email, $status);
            $stmt->execute();
            $lastInsertId = $mysqli->insert_id;
            $affectedRows = $mysqli->affected_rows;
            $stmt->close();
            ```

3.  **Обработка результатов:**
    *   Как показано выше, `fetchAll()` (PDO) или `fetch_all(MYSQLI_ASSOC)` (MySQLi) для получения всех строк.
    *   `fetch()` (PDO) или `fetch_assoc()` / `fetch_row()` / `fetch_object()` (MySQLi) для получения одной строки в цикле.

4.  **Закрытие соединения:**
    *   **PDO:** Соединение обычно закрывается автоматически, когда объект PDO уничтожается (например, при завершении скрипта). Можно присвоить `$pdo = null;` для явного закрытия.
    *   **MySQLi:** `$mysqli->close();`

**Обеспечение безопасности запросов к БД:**

Самая распространенная и опасная уязвимость при работе с БД — это **SQL-инъекция (SQL Injection)**. Она возникает, когда данные, полученные от пользователя, напрямую вставляются (конкатенируются) в SQL-запрос без должной обработки.

**Методы защиты:**

1.  **Подготовленные выражения (Prepared Statements / Parameterized Queries):**
    *   **Это наилучший и самый надежный способ защиты от SQL-инъекций.**
    *   **Принцип работы:**
        1.  SQL-запрос с плейсхолдерами (заполнителями, например `?` или `:name`) отправляется на сервер БД для подготовки (компиляции).
        2.  Затем данные (значения для плейсхолдеров) отправляются на сервер БД отдельно.
        3.  Сервер БД сам безопасно вставляет эти данные в скомпилированный запрос, экранируя все специальные символы. Таким образом, данные всегда трактуются как данные, а не как часть SQL-кода.
    *   Примеры использования PDO и MySQLi с подготовленными выражениями приведены выше.

2.  **Экранирование данных (Escaping):**
    *   Если по какой-то причине невозможно использовать подготовленные выражения (что крайне не рекомендуется), необходимо вручную экранировать все данные перед вставкой в SQL-запрос.
    *   **PDO:** `$pdo->quote($string)` (экранирует строку и обрамляет ее кавычками, подходит для строковых литералов).
    *   **MySQLi:** `$mysqli->real_escape_string($string)` (экранирует специальные символы в строке).
    *   **Это менее надежный способ**, так как легко забыть экранировать какие-то данные или сделать это неправильно. **Всегда предпочитайте подготовленные выражения.**
        ```php
        // НЕ РЕКОМЕНДУЕТСЯ! Пример с ручным экранированием (MySQLi)
        $unsafe_id = $_GET['id']; // Опасно!
        $safe_id = $mysqli->real_escape_string($unsafe_id);
        $sql = "SELECT * FROM products WHERE id = '" . $safe_id . "'"; // Все еще рискованно, если id - число
        // Для чисел лучше приведение типа: $safe_id = (int)$unsafe_id;
        ```

3.  **Валидация входных данных:**
    *   Всегда проверяйте тип, формат, диапазон и длину данных, приходящих от пользователя, *до* того, как они попадут в SQL-запрос. Например, если ожидается числовой ID, убедитесь, что это действительно число (`is_numeric()`, `filter_var($id, FILTER_VALIDATE_INT)`).

4.  **Принцип наименьших привилегий (Principle of Least Privilege):**
    *   Пользователь БД, от имени которого ваше PHP-приложение подключается к MySQL, должен иметь только те права, которые ему действительно необходимы. Например, если веб-страница только читает данные, пользователю БД не нужны права на `INSERT`, `UPDATE`, `DELETE` или `DROP TABLE`.

5.  **ORM (Object-Relational Mapper):**
    *   Библиотеки типа Doctrine, Eloquent (в Laravel) часто используют подготовленные выражения "под капотом", что помогает избежать SQL-инъекций. Однако важно понимать, как они работают.

6.  **Отключение вывода подробных ошибок БД на продакшене:**
    *   Подробные сообщения об ошибках SQL могут раскрыть структуру БД и другую чувствительную информацию злоумышленнику. На продакшн-сервере ошибки следует логировать, а пользователю показывать общее сообщение об ошибке.

**Пример уязвимого кода (НЕ ДЕЛАТЬ ТАК!):**
```php
$username = $_POST['username']; // Данные от пользователя
$password = $_POST['password']; // Данные от пользователя

// Прямая вставка в запрос - ОЧЕНЬ ОПАСНО!
$sql = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
$result = $mysqli->query($sql); // Если $username = "' OR '1'='1", то это может обойти аутентификацию
```
**Пример с использованием подготовленного выражения (ПРАВИЛЬНО):**
```php
$username = $_POST['username'];
$password = $_POST['password']; // Пароли должны храниться в хешированном виде! Сравнение хешей.

$stmt = $mysqli->prepare("SELECT id, password_hash FROM users WHERE username = ?");
$stmt->bind_param("s", $username);
$stmt->execute();
$result = $stmt->get_result();
$user = $result->fetch_assoc();

if ($user && password_verify($password, $user['password_hash'])) {
    // Успешная аутентификация
} else {
    // Ошибка аутентификации
}
$stmt->close();
```

---

### 10. Понятие сеанса. Сохранение состояния между запросами.

**Понятие сеанса (Session):**

Протокол HTTP по своей природе является **"stateless" (без состояния)**. Это означает, что каждый HTTP-запрос от клиента к серверу рассматривается как независимое событие. Сервер не хранит никакой информации о предыдущих запросах от того же клиента.

Однако для многих веб-приложений (интернет-магазины, форумы, админ-панели) необходимо сохранять информацию о пользователе между его запросами (например, содержимое корзины, данные авторизации, настройки). **Сеансы (сессии)** — это механизм, позволяющий веб-приложениям отслеживать состояние пользователя и хранить данные, специфичные для его визита, на протяжении нескольких запросов.

**Как работают сеансы в PHP (типичная схема):**

1.  **Инициализация сеанса:**
    *   Когда пользователь впервые обращается к странице, использующей сеансы, или когда сеанс нужно начать, вызывается функция `session_start()`.
    *   `session_start()` должна быть вызвана **в самом начале скрипта**, до любого вывода в браузер (HTML, пробелы, echo и т.д.), так как она может отправлять HTTP-заголовки (в частности, cookie).
2.  **Идентификатор сеанса (Session ID):**
    *   PHP проверяет, был ли передан идентификатор сеанса от клиента (обычно через HTTP cookie, по умолчанию с именем `PHPSESSID`).
    *   Если ID не передан или он недействителен, PHP генерирует новый уникальный идентификатор сеанса.
    *   Этот ID отправляется клиенту (браузеру) в виде cookie. Браузер будет автоматически отправлять этот cookie с каждым последующим запросом на тот же домен.
3.  **Хранение данных сеанса:**
    *   Данные сеанса хранятся **на сервере**. По умолчанию PHP сохраняет их в виде файлов в специальной директории (задается `session.save_path` в `php.ini`, часто это `/tmp` или `/var/lib/php/sessions`).
    *   Когда `session_start()` вызывается с валидным ID сеанса, PHP находит соответствующий файл данных сеанса на сервере и загружает его содержимое в суперглобальный массив `$_SESSION`.
4.  **Работа с данными сеанса:**
    *   После вызова `session_start()`, вы можете читать и записывать данные в массив `$_SESSION` так же, как с обычным массивом.
        ```php
        $_SESSION['username'] = 'JohnDoe';
        $_SESSION['cart_items'] = ['item1_id' => 2, 'item2_id' => 1];
        ```
5.  **Сохранение данных сеанса:**
    *   Когда скрипт завершает работу (или при вызове `session_write_close()`), PHP автоматически сериализует содержимое массива `$_SESSION` и сохраняет его в файл сеанса на сервере.

**Сохранение состояния между запросами с помощью сеансов:**

```php
<?php
// 1. Начать или возобновить сеанс. ОБЯЗАТЕЛЬНО ДО ЛЮБОГО ВЫВОДА!
session_start();

// Пример: счетчик посещений страницы для текущего пользователя
if (isset($_SESSION['page_views'])) {
    $_SESSION['page_views']++;
} else {
    $_SESSION['page_views'] = 1;
}

// Пример: сохранение имени пользователя после логина
if (isset($_POST['login']) && isset($_POST['username'])) {
    // (здесь должна быть проверка логина и пароля)
    $_SESSION['user_id'] = 123; // ID пользователя из БД
    $_SESSION['username'] = $_POST['username'];
    // Редирект на защищенную страницу
    header("Location: profile.php");
    exit;
}
?>
<!DOCTYPE html>
<html>
<head>
    <title>Страница с сеансом</title>
</head>
<body>
    <h1>Демонстрация сеансов</h1>

    <?php
    if (isset($_SESSION['username'])) {
        echo "<p>Привет, " . htmlspecialchars($_SESSION['username']) . "!</p>";
        echo "<p><a href='logout.php'>Выйти</a></p>";
    } else {
        echo "<p>Вы не авторизованы.</p>";
        echo '<form method="post">
                Имя пользователя: <input type="text" name="username"><br>
                <input type="submit" name="login" value="Войти">
              </form>';
    }

    echo "<p>Вы посетили эту страницу " . $_SESSION['page_views'] . " раз(а) в этом сеансе.</p>";
    ?>
</body>
</html>
```

**Завершение сеанса (Logout):**
```php
<?php
// logout.php
session_start();

// 1. Очистить все переменные сеанса
$_SESSION = array(); // или session_unset(); (удаляет переменные, но не сам файл сессии)

// 2. Если используется cookie для передачи ID сеанса, удалить cookie
if (ini_get("session.use_cookies")) {
    $params = session_get_cookie_params();
    setcookie(session_name(), '', time() - 42000, // Установить время жизни в прошлое
        $params["path"], $params["domain"],
        $params["secure"], $params["httponly"]
    );
}

// 3. Уничтожить сеанс (удалить файл сеанса на сервере)
session_destroy();

echo "Вы вышли из системы.";
// Редирект на главную или страницу входа
header("Location: index.php");
exit;
?>
```

**Важные настройки сеансов (в `php.ini` или через `ini_set()`):**

*   `session.save_handler`: Механизм хранения сеансов (по умолчанию `files`). Можно настроить хранение в БД, Memcached, Redis.
*   `session.save_path`: Путь к директории для хранения файлов сеансов (если `session.save_handler = files`).
*   `session.name`: Имя cookie, в котором передается ID сеанса (по умолчанию `PHPSESSID`).
*   `session.cookie_lifetime`: Время жизни cookie сеанса в секундах. `0` означает "до закрытия браузера".
*   `session.cookie_path`, `session.cookie_domain`: Область действия cookie.
*   `session.cookie_secure`: (`true`/`false`) Отправлять cookie только по HTTPS-соединению. **Рекомендуется `true` для продакшена.**
*   `session.cookie_httponly`: (`true`/`false`) Сделать cookie недоступным для JavaScript (защита от XSS). **Рекомендуется `true`.**
*   `session.use_cookies`: (`true`/`false`) Использовать ли cookie для передачи ID сеанса. **Рекомендуется `true`.**
*   `session.use_only_cookies`: (`true`/`false`) Использовать *только* cookie, запрещая передачу ID сеанса через URL (защита от фиксации сеанса). **Рекомендуется `true`.**
*   `session.gc_maxlifetime`: Время жизни неактивного сеанса на сервере в секундах. По истечении этого времени сборщик мусора (GC) может удалить файл сеанса.

**Безопасность сеансов:**

*   **Фиксация сеанса (Session Fixation):** Злоумышленник заставляет пользователя использовать известный ему ID сеанса. После того как пользователь аутентифицируется, злоумышленник может использовать этот ID.
    *   **Защита:** Генерировать новый ID сеанса после успешной аутентификации (или любого повышения привилегий) с помощью `session_regenerate_id(true);` (аргумент `true` удаляет старый файл сеанса).
*   **Перехват сеанса (Session Hijacking):** Злоумышленник крадет ID сеанса пользователя (например, через XSS, сниффинг незащищенного трафика).
    *   **Защита:** Использовать HTTPS (для шифрования трафика), `session.cookie_httponly = true`, `session.cookie_secure = true`, регулярная смена ID сеанса.
*   **Межсайтовая подделка запроса (CSRF):** Хотя напрямую не связана с механизмом сеансов, CSRF-атаки используют активный сеанс пользователя для выполнения несанкционированных действий от его имени.
    *   **Защита:** Использовать CSRF-токены.
*   Не храните в сеансе слишком много данных или очень чувствительную информацию (например, пароли в открытом виде).

Сеансы — мощный инструмент, но требуют внимательного отношения к конфигурации и безопасности.

---
Надеюсь, эти подробные ответы помогут вам подготовиться к экзамену! Удачи!